package device

import (
	"bytes"
	"crypto"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/hex"
	"encoding/pem"
	"errors"
	"io/ioutil"
	"log"

	pt "github.com/sewelol/sgx-decryption-service/prooftree"
)

// DEBUG - use key pairs from file
const DEBUG = true
const RSAOAEP = true

// Device global state data
type Device struct {
	signKey  *rsa.PrivateKey // Signing key-pair
	decKey   *rsa.PrivateKey // Decryption key-pair
	rootHash []byte          // Root hash in the Merkle Tree Log
}

// Init initializes the device
// Set initial RTH
// Generate RSA keys
func (d *Device) Init(initialHash []byte) *Device {
	d.rootHash = initialHash

	if DEBUG == true {
		d.decKey = debugImportRSAKey("test_set/crypt.pem")
		d.signKey = debugImportRSAKey("test_set/verif.pem")
	} else {
		d.decKey = generateKeyPair()
		d.signKey = generateKeyPair()
	}

	return d
}

// ----------- ECALLs (Interface functions) -------------

// Decrypt some ciphertext after verifying proofs that the request have been logged
func (d *Device) Decrypt(ciphertext []byte, pop, poe pt.ProofTree) (plaintext []byte, err error) {

	// Measure given ciphertext
	ctSum := sha256.Sum256(ciphertext)

	// Verify π: R in H'
	posRTH, err := d.verifyProofOfPresence(ctSum, pop)
	if err != nil {
		return nil, err
	}

	// Verify ρ: H' extends H
	poeRTH, err := d.verifyProofOfExtension(ctSum, poe)
	if err != nil {
		return nil, err
	}

	// Check if proofs match
	if posRTH != poeRTH {
		err = errors.New("Proofs could not be verified: Proof of presence/extension RTH missmatch")
		return nil, err
	}

	// new root tree hash after decryption
	newRTH := poeRTH

	// result := dec(dk, R)
	label := []byte("record") //OAEP label
	rng := rand.Reader

	if RSAOAEP == true {

		plaintext, err = rsa.DecryptOAEP(sha256.New(), rng, d.decKey, ciphertext, label)
		if err != nil {
			log.Printf("Error from OAEP decryption: %s\n", err)
		}

	} else {

		plaintext, err = rsa.DecryptPKCS1v15(rng, d.decKey, ciphertext)
		if err != nil {
			log.Printf("Error from PKCS1v15 decryption: %s\n", err)
		}
	}

	// H := H'
	log.Printf("Record decrypted! New RTH: %s", hex.EncodeToString(newRTH[:]))
	d.rootHash = newRTH[:]
	return plaintext, err
}

// SignRootTreeHash returns  RTH and sign(sha256(RTH + nonce)) from device
func (d *Device) SignRootTreeHash(nonce []byte) (rth []byte, sig []byte) {

	rng := rand.Reader
	h := sha256.Sum256(append(d.rootHash, nonce...))

	signature, err := rsa.SignPKCS1v15(rng, d.signKey, crypto.SHA256, h[:])
	if err != nil {
		log.Fatal(err)
	}
	return d.rootHash, signature
}

// ExportPubKey returns the public keys generated by the device (handeled during attestation to provide authentication)
func (d *Device) ExportPubKey() (encryptionKey, verificationKey []byte) {
	encryptionKey = publicKeyToPEM(d.decKey.PublicKey)
	verificationKey = publicKeyToPEM(d.signKey.PublicKey)
	return
}

// ---------- Proof verification functions ------------

// traverseProof traverses the proof tree
func traverseProof(node pt.ProofNode, order *[][32]byte) [32]byte {
	var l, r [32]byte

	if node.Hash != "" {
		b, err := hex.DecodeString(node.Hash)
		if err != nil {
			log.Fatal(err)
		}
		ret, err := sliceToHash(b)
		if err != nil {
			log.Fatal(err)
		}

		*order = append(*order, ret)

		return ret
	}

	l = traverseProof(*node.Left, order)
	r = traverseProof(*node.Right, order)

	// hack  to comply with Dom's hash tree
	// TODO: Dom should hash the byte array, not the hex encoded string..
	ls := hex.EncodeToString(l[:])
	rs := hex.EncodeToString(r[:])
	buf := []byte(ls + rs)

	// buf := append(l[:], r[:]...)

	return sha256.Sum256(buf)
}

// verifyProofOfPresence parses the json formatted proof, and verifies the result, returns true or false
func (d *Device) verifyProofOfPresence(ctSum [32]byte, p pt.ProofTree) (computedRTH [32]byte, err error) {

	// presence list
	order := new([][32]byte)

	// Traverse proof tree, compute the new RTH and add leafs to order
	computedRTH = traverseProof(p.Root, order)

	// Decode Hex string and copy to an array
	buf, err := hex.DecodeString(p.RTH)
	if err != nil {
		return
	}
	declaredRTH, err := sliceToHash(buf)
	if err != nil {
		return
	}

	// Check if declared RTH and computed RTH are equal
	if declaredRTH != computedRTH {
		err = errors.New("Presence could not be verified: Declared and computed RTH missmatch")
		return
	}

	// Check if proof_val actually is included in the proof
	if containsHash(*order, ctSum) != true {
		err = errors.New("Presence could not be verified: Record not present in proof tree")
		return
	}

	// The value is present in the valid RTH that was just computed.
	// Return computed RTH
	return computedRTH, nil
}

// verifyProofOfExtension parses the json formatted proof, and verifies the result, returns true or false
func (d *Device) verifyProofOfExtension(ctSum [32]byte, p pt.ProofTree) (RTH [32]byte, err error) {

	// Presence lists
	var oldOrder [][32]byte
	var newOrder [][32]byte

	// Compute old and new RTH
	oldComputedRTH := traverseProof(p.OldProof, &oldOrder)
	newComputedRTH := traverseProof(p.NewProof, &newOrder)

	// Check if computed old RTH match device's RTH
	if bytes.Compare(oldComputedRTH[:], d.rootHash) > 0 {
		err = errors.New("Proof RTH does not match current internal state")
		return
	}

	// Check that oldOrder is a subset of newOrder
	for i, v := range oldOrder {
		if v != newOrder[i] {
			err = errors.New("Old proof is not a subset of new proof")
			return
		}
	}

	RTH = newComputedRTH
	return RTH, nil
}

// ---------- AUX functions ------------

// generateKeyPair will generate a pair of RSA keys
func generateKeyPair() *rsa.PrivateKey {
	reader := rand.Reader
	bitSize := 2048
	key, err := rsa.GenerateKey(reader, bitSize)
	if err != nil {
		log.Fatal(err)
	}

	return key
}

func publicKeyToPEM(pk rsa.PublicKey) (pubBytes []byte) {
	PubASN1, err := x509.MarshalPKIXPublicKey(&pk)
	if err != nil {
		log.Fatal(err)
	}

	pubBytes = pem.EncodeToMemory(&pem.Block{
		Type:  "RSA PUBLIC KEY",
		Bytes: PubASN1,
	})
	return
}

func privateKeyToPEM(sk rsa.PrivateKey) (privBytes []byte) {
	PrivASN1 := x509.MarshalPKCS1PrivateKey(&sk)

	privBytes = pem.EncodeToMemory(&pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: PrivASN1,
	})
	return
}

func debugImportRSAKey(filename string) *rsa.PrivateKey {

	pemkey, err := ioutil.ReadFile(filename) // "test_set/crypto.pem"
	if err != nil {
		log.Fatal(err)
	}

	pemBlock, _ := pem.Decode(pemkey)
	if pemBlock == nil {
		log.Fatal("No PEM block decoded")
	}

	key, err := x509.ParsePKCS1PrivateKey(pemBlock.Bytes)
	// key, err := x509.ParsePKCS8PrivateKey(pemBlock.Bytes)
	if err != nil {
		log.Fatal(err)
	}

	return key
}

func containsHash(s [][32]byte, e [32]byte) bool {
	for _, a := range s {
		if a == e {
			return true
		}
	}
	return false
}

func sliceToHash(slice []byte) (hash [32]byte, err error) {
	if len(slice) > len(hash) {
		err = errors.New("sliceToHash: slice is to long")
		return
	}

	copy(hash[:], slice)
	return
}
