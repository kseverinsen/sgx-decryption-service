package device

import (
	"crypto"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"log"
)

// Device data
type Device struct {
	signKey  *rsa.PrivateKey // Signing key-pair
	decKey   *rsa.PrivateKey // Decryption key-pair
	rootHash string          // Root hash in the Merkle Tree Log
}

// New Device
func New(string initialHash) *Device {
	d := new(Device)
	d.rootHash = initialHash
	d.signKey = generateKeyPair()
	d.decKey = generateKeyPair()

	return d
}

// ----------- ECALLs -------------

// Decrypt some ciphertext after verifying proofs that the request have been logged
func (d *Device) Decrypt(ciphertext []byte) []byte {

	label := []byte("record")
	rng := rand.Reader

	// Verify π: R in H'

	// Verify ρ: H' extends H

	// result := dec(dk, R)
	plaintext, err := rsa.DecryptOAEP(sha256.New(), rng, d.decKey, ciphertext, label)
	if err != nil {
		log.Fatalf("Error from decryption: %s\n", err)
	}

	// H := H'
	return plaintext
}

// ChallengeReponse will sign a challenge, and return the signature 
// TODO: sign RTH as well you fool
func (d *Device) ChallengeReponse(challenge []byte) []byte {

	rng := rand.Reader
	h := sha256.Sum256(challenge)

	signature, err := rsa.SignPKCS1v15(rng, d.signKey, crypto.SHA256, h[:])
	if err != nil {
		log.Fatal(err)
	}
	return signature
}

// ---------- AUX functions ------------

// ExportPubKey returns the public keys generated by the device (handeled during attestation to provide authentication)
func (d *Device) ExportPubKey() (rsa.PublicKey, rsa.PublicKey) {
	return d.decKey.PublicKey, d.signKey.PublicKey
}

// generateKeyPair will generate a pair of RSA keys
func generateKeyPair() *rsa.PrivateKey {
	reader := rand.Reader
	bitSize := 2048
	key, err := rsa.GenerateKey(reader, bitSize)
	if err != nil {
		log.Fatal(err)
	}

	return key
}
