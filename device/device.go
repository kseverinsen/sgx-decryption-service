package device

import (
	"crypto"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/pem"
	"log"
)

// Device data
type Device struct {
	signKey  *rsa.PrivateKey // Signing key-pair
	decKey   *rsa.PrivateKey // Decryption key-pair
	rootHash []byte          // Root hash in the Merkle Tree Log
}

// Init initializes the device
// Set initial RTH
// Generate RSA keys
func (d *Device) Init(initialHash []byte) *Device {
	d.rootHash = initialHash
	d.signKey = generateKeyPair()
	d.decKey = generateKeyPair()

	return d
}

// ----------- ECALLs -------------

// Decrypt some ciphertext after verifying proofs that the request have been logged
func (d *Device) Decrypt(ciphertext []byte) []byte {

	label := []byte("record")
	rng := rand.Reader

	// Verify π: R in H'

	// Verify ρ: H' extends H

	// result := dec(dk, R)
	plaintext, err := rsa.DecryptOAEP(sha256.New(), rng, d.decKey, ciphertext, label)
	if err != nil {
		log.Fatalf("Error from decryption: %s\n", err)
	}

	// H := H'
	return plaintext
}

// SignRootTreeHash returns  RTH and sign(sha256(RTH + nonce)) from device
func (d *Device) SignRootTreeHash(nonce []byte) (rth []byte, sig []byte) {

	rng := rand.Reader
	h := sha256.Sum256(append(rth, nonce...))

	signature, err := rsa.SignPKCS1v15(rng, d.signKey, crypto.SHA256, h[:])
	if err != nil {
		log.Fatal(err)
	}
	return d.rootHash, signature
}

// ExportPubKey returns the public keys generated by the device (handeled during attestation to provide authentication)
func (d *Device) ExportPubKey() (encryptionKey, verificationKey []byte) {
	encryptionKey = publicKeyToPEM(d.decKey.PublicKey)
	verificationKey = publicKeyToPEM(d.signKey.PublicKey)
	return
}

// ---------- AUX functions ------------

// generateKeyPair will generate a pair of RSA keys
func generateKeyPair() *rsa.PrivateKey {
	reader := rand.Reader
	bitSize := 2048
	key, err := rsa.GenerateKey(reader, bitSize)
	if err != nil {
		log.Fatal(err)
	}

	return key
}

func publicKeyToPEM(pk rsa.PublicKey) (pubBytes []byte) {
	PubASN1, err := x509.MarshalPKIXPublicKey(&pk)
	if err != nil {
		log.Fatal(err)
	}

	pubBytes = pem.EncodeToMemory(&pem.Block{
		Type:  "RSA PUBLIC KEY",
		Bytes: PubASN1,
	})
	return
}
