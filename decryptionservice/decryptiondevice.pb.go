// Code generated by protoc-gen-go. DO NOT EDIT.
// source: decryptiondevice.proto

/*
Package decryptiondevice is a generated protocol buffer package.

It is generated from these files:
	decryptiondevice.proto

It has these top-level messages:
	DecryptionRequest
	Record
	RootTreeHashRequest
	RootTreeHash
	PublicKeyRequest
	Quote
*/
package decryptiondevice

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Decryption Request
// - Byte array containing ciphertext
// - Proofs represented as JSON trees
type DecryptionRequest struct {
	Ciphertext       []byte `protobuf:"bytes,1,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
	ProofOfPresence  string `protobuf:"bytes,2,opt,name=proofOfPresence" json:"proofOfPresence,omitempty"`
	ProofOfExtension string `protobuf:"bytes,3,opt,name=proofOfExtension" json:"proofOfExtension,omitempty"`
}

func (m *DecryptionRequest) Reset()                    { *m = DecryptionRequest{} }
func (m *DecryptionRequest) String() string            { return proto.CompactTextString(m) }
func (*DecryptionRequest) ProtoMessage()               {}
func (*DecryptionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *DecryptionRequest) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *DecryptionRequest) GetProofOfPresence() string {
	if m != nil {
		return m.ProofOfPresence
	}
	return ""
}

func (m *DecryptionRequest) GetProofOfExtension() string {
	if m != nil {
		return m.ProofOfExtension
	}
	return ""
}

// A plaintext record
type Record struct {
	Plaintext []byte `protobuf:"bytes,1,opt,name=plaintext,proto3" json:"plaintext,omitempty"`
}

func (m *Record) Reset()                    { *m = Record{} }
func (m *Record) String() string            { return proto.CompactTextString(m) }
func (*Record) ProtoMessage()               {}
func (*Record) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Record) GetPlaintext() []byte {
	if m != nil {
		return m.Plaintext
	}
	return nil
}

// RTH request contains
// - A random nonce
type RootTreeHashRequest struct {
	Nonce []byte `protobuf:"bytes,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *RootTreeHashRequest) Reset()                    { *m = RootTreeHashRequest{} }
func (m *RootTreeHashRequest) String() string            { return proto.CompactTextString(m) }
func (*RootTreeHashRequest) ProtoMessage()               {}
func (*RootTreeHashRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *RootTreeHashRequest) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

// Root Tree Hash
// Random nonce used as message ID
// Signature over rth and nonce
type RootTreeHash struct {
	Rth   []byte `protobuf:"bytes,1,opt,name=rth,proto3" json:"rth,omitempty"`
	Nonce []byte `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	Sig   []byte `protobuf:"bytes,3,opt,name=sig,proto3" json:"sig,omitempty"`
}

func (m *RootTreeHash) Reset()                    { *m = RootTreeHash{} }
func (m *RootTreeHash) String() string            { return proto.CompactTextString(m) }
func (*RootTreeHash) ProtoMessage()               {}
func (*RootTreeHash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *RootTreeHash) GetRth() []byte {
	if m != nil {
		return m.Rth
	}
	return nil
}

func (m *RootTreeHash) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *RootTreeHash) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

// Public key request message
type PublicKeyRequest struct {
	Nonce []byte `protobuf:"bytes,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *PublicKeyRequest) Reset()                    { *m = PublicKeyRequest{} }
func (m *PublicKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*PublicKeyRequest) ProtoMessage()               {}
func (*PublicKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PublicKeyRequest) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

// Attestation Quote, containing the public key
type Quote struct {
	Quote string `protobuf:"bytes,1,opt,name=quote" json:"quote,omitempty"`
	// PEM formatted key
	RSA_EncryptionKey   []byte `protobuf:"bytes,2,opt,name=RSA_EncryptionKey,json=RSAEncryptionKey,proto3" json:"RSA_EncryptionKey,omitempty"`
	RSA_VerificationKey []byte `protobuf:"bytes,3,opt,name=RSA_VerificationKey,json=RSAVerificationKey,proto3" json:"RSA_VerificationKey,omitempty"`
}

func (m *Quote) Reset()                    { *m = Quote{} }
func (m *Quote) String() string            { return proto.CompactTextString(m) }
func (*Quote) ProtoMessage()               {}
func (*Quote) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Quote) GetQuote() string {
	if m != nil {
		return m.Quote
	}
	return ""
}

func (m *Quote) GetRSA_EncryptionKey() []byte {
	if m != nil {
		return m.RSA_EncryptionKey
	}
	return nil
}

func (m *Quote) GetRSA_VerificationKey() []byte {
	if m != nil {
		return m.RSA_VerificationKey
	}
	return nil
}

func init() {
	proto.RegisterType((*DecryptionRequest)(nil), "decryptiondevice.DecryptionRequest")
	proto.RegisterType((*Record)(nil), "decryptiondevice.Record")
	proto.RegisterType((*RootTreeHashRequest)(nil), "decryptiondevice.RootTreeHashRequest")
	proto.RegisterType((*RootTreeHash)(nil), "decryptiondevice.RootTreeHash")
	proto.RegisterType((*PublicKeyRequest)(nil), "decryptiondevice.PublicKeyRequest")
	proto.RegisterType((*Quote)(nil), "decryptiondevice.Quote")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DecryptionDevice service

type DecryptionDeviceClient interface {
	// Decryption Request RPC
	//
	// Request contains ciphertext and proof
	// Returns the plaintext record
	DecryptRecord(ctx context.Context, in *DecryptionRequest, opts ...grpc.CallOption) (*Record, error)
	// Get Signed Root Tree Hash RPC
	//
	// Caller provides a nonce
	// Returns a signed RTH and nonce
	GetRootTreeHash(ctx context.Context, in *RootTreeHashRequest, opts ...grpc.CallOption) (*RootTreeHash, error)
	// Get Public key RPC
	//
	// Returns a Remote attestation report containing the public key as user data
	GetPublicKey(ctx context.Context, in *PublicKeyRequest, opts ...grpc.CallOption) (*Quote, error)
}

type decryptionDeviceClient struct {
	cc *grpc.ClientConn
}

func NewDecryptionDeviceClient(cc *grpc.ClientConn) DecryptionDeviceClient {
	return &decryptionDeviceClient{cc}
}

func (c *decryptionDeviceClient) DecryptRecord(ctx context.Context, in *DecryptionRequest, opts ...grpc.CallOption) (*Record, error) {
	out := new(Record)
	err := grpc.Invoke(ctx, "/decryptiondevice.DecryptionDevice/DecryptRecord", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decryptionDeviceClient) GetRootTreeHash(ctx context.Context, in *RootTreeHashRequest, opts ...grpc.CallOption) (*RootTreeHash, error) {
	out := new(RootTreeHash)
	err := grpc.Invoke(ctx, "/decryptiondevice.DecryptionDevice/GetRootTreeHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *decryptionDeviceClient) GetPublicKey(ctx context.Context, in *PublicKeyRequest, opts ...grpc.CallOption) (*Quote, error) {
	out := new(Quote)
	err := grpc.Invoke(ctx, "/decryptiondevice.DecryptionDevice/GetPublicKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DecryptionDevice service

type DecryptionDeviceServer interface {
	// Decryption Request RPC
	//
	// Request contains ciphertext and proof
	// Returns the plaintext record
	DecryptRecord(context.Context, *DecryptionRequest) (*Record, error)
	// Get Signed Root Tree Hash RPC
	//
	// Caller provides a nonce
	// Returns a signed RTH and nonce
	GetRootTreeHash(context.Context, *RootTreeHashRequest) (*RootTreeHash, error)
	// Get Public key RPC
	//
	// Returns a Remote attestation report containing the public key as user data
	GetPublicKey(context.Context, *PublicKeyRequest) (*Quote, error)
}

func RegisterDecryptionDeviceServer(s *grpc.Server, srv DecryptionDeviceServer) {
	s.RegisterService(&_DecryptionDevice_serviceDesc, srv)
}

func _DecryptionDevice_DecryptRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecryptionDeviceServer).DecryptRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/decryptiondevice.DecryptionDevice/DecryptRecord",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecryptionDeviceServer).DecryptRecord(ctx, req.(*DecryptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DecryptionDevice_GetRootTreeHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RootTreeHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecryptionDeviceServer).GetRootTreeHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/decryptiondevice.DecryptionDevice/GetRootTreeHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecryptionDeviceServer).GetRootTreeHash(ctx, req.(*RootTreeHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DecryptionDevice_GetPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DecryptionDeviceServer).GetPublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/decryptiondevice.DecryptionDevice/GetPublicKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DecryptionDeviceServer).GetPublicKey(ctx, req.(*PublicKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DecryptionDevice_serviceDesc = grpc.ServiceDesc{
	ServiceName: "decryptiondevice.DecryptionDevice",
	HandlerType: (*DecryptionDeviceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DecryptRecord",
			Handler:    _DecryptionDevice_DecryptRecord_Handler,
		},
		{
			MethodName: "GetRootTreeHash",
			Handler:    _DecryptionDevice_GetRootTreeHash_Handler,
		},
		{
			MethodName: "GetPublicKey",
			Handler:    _DecryptionDevice_GetPublicKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "decryptiondevice.proto",
}

func init() { proto.RegisterFile("decryptiondevice.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 391 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x93, 0x5f, 0xcb, 0xda, 0x30,
	0x14, 0xc6, 0xad, 0x2f, 0xef, 0x0b, 0x1e, 0x3a, 0xac, 0x71, 0x7f, 0x8a, 0x0c, 0x91, 0x8c, 0x8d,
	0x32, 0xc1, 0xc1, 0xfc, 0x04, 0x8a, 0xa2, 0x20, 0x63, 0x5d, 0x1c, 0xbb, 0xd8, 0xcd, 0xd0, 0x78,
	0xd4, 0x80, 0x34, 0x35, 0x8d, 0x43, 0xd9, 0x27, 0xd8, 0xd5, 0xbe, 0xf2, 0x48, 0x5b, 0xb5, 0x36,
	0x2f, 0xde, 0x25, 0xcf, 0xf9, 0x1d, 0xce, 0xe1, 0x79, 0x12, 0x78, 0xbd, 0x42, 0xae, 0x4e, 0xb1,
	0x16, 0x32, 0x5a, 0xe1, 0x6f, 0xc1, 0xb1, 0x17, 0x2b, 0xa9, 0x25, 0xf1, 0xca, 0x3a, 0xfd, 0xeb,
	0x40, 0x63, 0x74, 0x11, 0x19, 0xee, 0x0f, 0x98, 0x68, 0xd2, 0x06, 0xe0, 0x22, 0xde, 0xa2, 0xd2,
	0x78, 0xd4, 0xbe, 0xd3, 0x71, 0x02, 0x97, 0x15, 0x14, 0x12, 0x40, 0x3d, 0x56, 0x52, 0xae, 0xbf,
	0xae, 0x43, 0x85, 0x09, 0x46, 0x1c, 0xfd, 0x6a, 0xc7, 0x09, 0x6a, 0xac, 0x2c, 0x93, 0x8f, 0xe0,
	0xe5, 0xd2, 0xf8, 0xa8, 0x31, 0x4a, 0x84, 0x8c, 0xfc, 0x87, 0x14, 0xb5, 0x74, 0xfa, 0x01, 0x9e,
	0x18, 0x72, 0xa9, 0x56, 0xe4, 0x2d, 0xd4, 0xe2, 0xdd, 0x42, 0x44, 0x85, 0xf1, 0x57, 0x81, 0x76,
	0xa1, 0xc9, 0xa4, 0xd4, 0xdf, 0x15, 0xe2, 0x74, 0x91, 0x6c, 0xcf, 0x4b, 0xbf, 0x84, 0xc7, 0x48,
	0x9a, 0x55, 0xb2, 0x86, 0xec, 0x42, 0xa7, 0xe0, 0x16, 0x61, 0xe2, 0xc1, 0x83, 0xd2, 0xdb, 0x9c,
	0x31, 0xc7, 0x6b, 0x5f, 0xb5, 0xd0, 0x67, 0xb8, 0x44, 0x6c, 0xd2, 0x5d, 0x5d, 0x66, 0x8e, 0x34,
	0x00, 0x2f, 0x3c, 0x2c, 0x77, 0x82, 0xcf, 0xf0, 0x74, 0x7f, 0xe6, 0x1f, 0x78, 0xfc, 0x76, 0x90,
	0x1a, 0x4d, 0x79, 0x6f, 0x0e, 0x69, 0xb9, 0xc6, 0xb2, 0x0b, 0xe9, 0x42, 0x83, 0xcd, 0x07, 0xbf,
	0xc6, 0xd1, 0xd9, 0xf6, 0x19, 0x9e, 0xf2, 0xe1, 0x1e, 0x9b, 0x0f, 0x6e, 0x74, 0xf2, 0x09, 0x9a,
	0x06, 0xfe, 0x81, 0x4a, 0xac, 0x05, 0x5f, 0x9c, 0xf1, 0x6c, 0x2f, 0xc2, 0xe6, 0x83, 0x52, 0xe5,
	0xf3, 0xbf, 0x2a, 0x78, 0xd7, 0x44, 0x47, 0x69, 0xcc, 0x24, 0x84, 0x17, 0xb9, 0x96, 0x3b, 0xfc,
	0xae, 0x67, 0x3d, 0x11, 0xeb, 0x19, 0xb4, 0x7c, 0x1b, 0xca, 0xda, 0x69, 0x85, 0xfc, 0x84, 0xfa,
	0x04, 0xf5, 0x8d, 0xb5, 0xef, 0x9f, 0xc1, 0xed, 0x9c, 0x5a, 0xed, 0xfb, 0x18, 0xad, 0x90, 0x2f,
	0xe0, 0x4e, 0x50, 0x5f, 0xcc, 0x26, 0xd4, 0xee, 0x28, 0x27, 0xd1, 0x7a, 0x63, 0x33, 0x69, 0x06,
	0xb4, 0x32, 0xec, 0x83, 0x2f, 0x64, 0x6f, 0xa3, 0x62, 0x6e, 0x31, 0xc3, 0x57, 0x65, 0xab, 0x42,
	0xf3, 0x51, 0x42, 0x67, 0xf9, 0x94, 0xfe, 0x98, 0xfe, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5d,
	0xb0, 0x61, 0x0d, 0x4b, 0x03, 0x00, 0x00,
}
